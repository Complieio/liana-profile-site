<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Liana — profile</title>

  <style>
    :root{
      --accent-gradient: linear-gradient(90deg, #FF3D3D 0%, #FF914D 100%);
      --bg-color: #000;
      --text: #e6e6e6;
      --muted: #bdbdbd;
      --max-width: 820px;
    }

    /* Reset / base */
    * { box-sizing: border-box; }
    html,body {
      height: 100vh;
      margin: 0;
      overflow: hidden; /* prevent scrolling */
      background: var(--bg-color);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    a { text-decoration: none; }

    /* Canvas background (the orange pixel effect) */
    canvas#bgCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;              /* behind the page content */
      pointer-events: none;    /* won't block clicks */
      display:block;
      background: transparent;
    }

    /* Page layout */
    .page {
      /* fixed to viewport height so page does not scroll */
      height: 100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:56px 20px;
      z-index:1;
      position:relative;
      overflow: hidden;
    }
    .container {
      width:100%;
      max-width: var(--max-width);
      margin: 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 22px;
      transform-origin: center;
      opacity: 0;
      transform: translateY(12px) scale(0.995);
      transition: opacity 520ms cubic-bezier(.2,.9,.2,1), transform 520ms cubic-bezier(.2,.9,.2,1);
      will-change: opacity, transform;
    }

    .container.show {
      opacity: 1;
      transform: none;
    }

    /* Photo: centered medium size with slightly rounded corners */
    .photo {
      width: 200px;
      height: 200px;
      object-fit: cover;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      display:block;
      transform-origin: center;
      transform: scale(0.96) rotate(-0.8deg);
      opacity: 0;
      transition: transform 520ms cubic-bezier(.2,.9,.25,1), opacity 520ms cubic-bezier(.2,.9,.25,1);
    }

    .photo.show {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }

    /* Content column */
    .content {
      width:100%;
      padding: 0 12px;
      color: var(--muted);
      line-height:1.55;
      text-align: left;
      transform-origin: left top;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 520ms cubic-bezier(.2,.9,.25,1) 120ms, transform 520ms cubic-bezier(.2,.9,.25,1) 120ms;
    }

    .content.show {
      opacity: 1;
      transform: none;
    }

    .intro {
      margin: 8px 0 12px 0;
      color: var(--text);
      font-size: 15px;
    }

    .current, .email {
      margin: 6px 0 12px 0;
      color: var(--muted);
      font-size: 15px;
    }

    /* Generic anchor color for non-accent links */
    a:not(.accent-link) { color: #ffaf88; }

    /* Gradient-accent links (keeps priority by using the class) */
    .accent-link {
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
      font-weight: 600;
    }
    a.accent-link:visited { opacity: 0.95; }

    /* Lists */
    .content h3 { margin-top:14px; margin-bottom:8px; color:var(--text); font-size:15px; }
    ul { margin:6px 0 12px 20px; padding:0; }
    li { margin-bottom:8px; color:var(--muted); }

    .social-label { color: var(--text); font-weight:600; margin-right:6px; }

    /* small screen tweaks */
    @media (max-width:640px) {
      .photo { width:160px; height:160px; border-radius:10px; }
      .container { padding: 0 6px; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      canvas#bgCanvas { display: none; }
      .container, .photo, .content { transition: none; transform: none; opacity: 1 !important; }
    }

    /* hidden mask image (for authoring only) */
    img#scribbleMask { display:none; }
  </style>
</head>
<body>
  <!-- Canvas for the small-square trail effect -->
  <canvas id="bgCanvas" aria-hidden="true"></canvas>

  <!-- Hidden mask image: place your drawn-scribbles image here -->
  <img id="scribbleMask" src="/assets/scribble-mask.png" alt="scribble mask" crossorigin="anonymous" />

  <main class="page">
    <div class="container" id="pageContainer">

      <!-- Photo (centered) -->
      <!-- Updated src to use the provided filename; place the file at assets/profileIcon_c8shkbcvzn2g1.jpeg in your repo -->
      <img class="photo" id="profilePhoto" src="/assets/profileIcon_c8shkbcvzn2g1.jpeg" alt="Liana portrait" width="200" height="200" loading="lazy" />

      <!-- Content area -->
      <div class="content" id="textContent">
        <p class="intro">
          I'm Liana, a 14 y/o entrepreneur based in Sweden. I like reading, creating stuff online, and finding new things worth getting good at.
        </p>

        <p class="current">
          Founder of
          <!-- clickable gradient link to complie -->
          <a class="accent-link" href="https://complie.io" target="_blank" rel="noopener">Complie.io</a>
           — tools that help professionals track their clients, projects, and tasks in a more efficient way.
        </p>

        <h3>Experience</h3>
        <ul>
          <li>Freelanced building websites</li>
          <li>Edited videos + clips for creators</li>
          <li>Created faceless YouTube content</li>
          <li>Skilled in video editing &amp; graphic design</li>
          <li>Sales experience through consistent outreach</li>
          <li>Built a platform (Complie)</li>
        </ul>

        <h3>Socials</h3>
        <ul>
          <li>
            <span class="social-label">X:</span>
            <a class="accent-link" href="https://x.com/Lianarooz" target="_blank" rel="noopener">@Lianarooz</a>
          </li>
          <li>
            <span class="social-label">LinkedIn:</span>
            <a class="accent-link" href="https://www.linkedin.com/in/liana-roozbahani-998956353/" target="_blank" rel="noopener">Liana Roozbahani</a>
          </li>
          <li>
            <span class="social-label">Instagram:</span>
            <a class="accent-link" href="https://www.instagram.com/lianaroozbahani/" target="_blank" rel="noopener">@lianaroozbahani</a>
          </li>
          <li>
            <span class="social-label">GitHub:</span>
            <a class="accent-link" href="https://github.com/Complieio" target="_blank" rel="noopener">Complieio</a>
          </li>
          <li>
            <span class="social-label">Email:</span>
            <a class="accent-link" href="mailto:roozbahaniliana@gmail.com">roozbahaniliana@gmail.com</a>
          </li>
        </ul>
      </div>
    </div>
  </main>

  <script>
    (function () {
      const canvas = document.getElementById('bgCanvas');
      const ctx = canvas.getContext('2d', { alpha: true });

      // ---------- Tweak these to change the effect ----------
      // Mouse-driven particle settings (left untouched from your original)
      const SPAWN_COUNT = 3;        // how many squares to spawn per mousemove event (1-6)
      const PARTICLE_MIN_SIZE = 6;  // px (small squares)
      const PARTICLE_MAX_SIZE = 12; // px
      const LIFESPAN_MIN = 300;     // ms
      const LIFESPAN_MAX = 700;     // ms
      const MAX_PARTICLES = 1200;   // increased cap to allow corner emitters too
      const FRICTION = 0.86;        // how quickly particles slow
      // Ambient / mask sampling
      const MASK_SAMPLE_STEP = 8;
      const MASK_THRESHOLD = 600;
      // Corner emitter specifics (separate from mouse particles)
      const CORNER = {
        // number of squares per spawn in corners (1-6)
        minSpawn: 1,
        maxSpawn: 3,
        sizeMin: 4,
        sizeMax: 10,
        lifeMin: 800,
        lifeMax: 1600,
        // base speed multiplier for corner particles
        speedMin: 0.8,
        speedMax: 2.4,
        // how often a corner tries to emit (ms)
        intervalMin: 700,
        intervalMax: 1700,
        // subtle directional spread inward (degrees)
        spreadDeg: 28
      };
      // -----------------------------------------------------

      let DPR = Math.max(window.devicePixelRatio || 1, 1);
      let width = 0, height = 0;
      let particles = [];
      let maskPoints = []; // allowed ambient spawn coords
      let maskReady = false;
      const maskImg = document.getElementById('scribbleMask');

      function resize() {
        DPR = Math.max(window.devicePixelRatio || 1, 1);
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.width = Math.round(width * DPR);
        canvas.height = Math.round(height * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

        if (maskImg && maskImg.complete) buildMaskPoints();
      }

      // create a single particle (used by both mouse and corner spawners)
      function spawnParticle(x, y, vx = 0, vy = 0, opts = {}) {
        if (particles.length >= MAX_PARTICLES) return;
        const size = opts.size ?? randRange(PARTICLE_MIN_SIZE, PARTICLE_MAX_SIZE);
        const life = opts.life ?? randRange(LIFESPAN_MIN, LIFESPAN_MAX);
        // color blend between two oranges for slight variety
        const colorA = opts.colorA ?? [255, 61, 61];   // #FF3D3D
        const colorB = opts.colorB ?? [255, 145, 77];  // #FF914D
        const mix = Math.random();
        const r = Math.round(lerp(colorA[0], colorB[0], mix));
        const g = Math.round(lerp(colorA[1], colorB[1], mix));
        const b = Math.round(lerp(colorA[2], colorB[2], mix));
        particles.push({
          x, y,
          vx: vx + randRange(-0.45, 0.45),
          vy: vy + randRange(-0.45, 0.45),
          size,
          life,
          age: 0,
          rgb: [r, g, b]
        });
      }

      // EXACT original velocity math preserved here (mouse)
      function handleMove(clientX, clientY, movementX, movementY) {
        for (let i = 0; i < SPAWN_COUNT; i++) {
          const ox = randRange(-4, 4);
          const oy = randRange(-4, 4);
          const vx = movementX * 0.15 + randRange(-0.6, 0.6);
          const vy = movementY * 0.15 + randRange(-0.6, 0.6);
          spawnParticle(clientX + ox, clientY + oy, vx, vy);
        }
      }

      // spawn a radial burst from a center point (used on load)
      function spawnBurst(cx, cy, count = 40, speed = 3.5) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const spd = randRange(speed * 0.4, speed * 1.1);
          const vx = Math.cos(angle) * spd + randRange(-0.6, 0.6);
          const vy = Math.sin(angle) * spd + randRange(-0.6, 0.6);
          const ox = Math.cos(angle) * randRange(0, 6);
          const oy = Math.sin(angle) * randRange(0, 6);
          spawnParticle(cx + ox, cy + oy, vx, vy);
        }
      }

      // Build mask points from the scribble image
      function buildMaskPoints() {
        try {
          const off = document.createElement('canvas');
          off.width = width;
          off.height = height;
          const octx = off.getContext('2d');
          octx.clearRect(0, 0, off.width, off.height);
          octx.drawImage(maskImg, 0, 0, off.width, off.height);

          const id = octx.getImageData(0, 0, off.width, off.height);
          const data = id.data;
          maskPoints = [];
          for (let y = 0; y < off.height; y += MASK_SAMPLE_STEP) {
            for (let x = 0; x < off.width; x += MASK_SAMPLE_STEP) {
              const idx = (y * off.width + x) * 4;
              const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
              const bright = r + g + b;
              if (a > 80 && bright >= MASK_THRESHOLD) {
                maskPoints.push({ x: x + randRange(-MASK_SAMPLE_STEP/2, MASK_SAMPLE_STEP/2), y: y + randRange(-MASK_SAMPLE_STEP/2, MASK_SAMPLE_STEP/2) });
              }
            }
          }
          maskReady = maskPoints.length > 0;
        } catch (err) {
          maskPoints = [];
          maskReady = false;
        }
      }

      // Ambient spawn (uses mask if available) - unchanged behavior
      let ambientTimer = 0;
      function maybeAmbient(now) {
        if (!maskReady) {
          if (now - ambientTimer > randRange(1600, 3000)) {
            ambientTimer = now;
            const cx = randRange(width * 0.25, width * 0.75);
            const cy = randRange(height * 0.2, height * 0.8);
            const n = Math.round(randRange(1, 4));
            for (let i = 0; i < n; i++) {
              spawnParticle(cx + randRange(-20,20), cy + randRange(-20,20), randRange(-0.4,0.4), randRange(-0.4,0.4));
            }
          }
          return;
        }
        if (now - ambientTimer > randRange(1600, 3000)) {
          ambientTimer = now;
          const idx = Math.floor(Math.random() * maskPoints.length);
          const base = maskPoints[idx];
          const n = Math.round(randRange(1, 4));
          for (let i = 0; i < n; i++) {
            const jitterX = randRange(-18, 18);
            const jitterY = randRange(-18, 18);
            spawnParticle(base.x + jitterX, base.y + jitterY, randRange(-0.4,0.4), randRange(-0.4,0.4));
          }
        }
      }

      // ---------- Corner emitters (new) ----------
      // corners: TL, TR, BL, BR
      const corners = [
        { name: 'top-left',   x: () => 0,    y: () => 0,    dirX: 1, dirY: 1 },
        { name: 'top-right',  x: () => width, y: () => 0,    dirX: -1, dirY: 1 },
        { name: 'bottom-left',x: () => 0,    y: () => height,dirX: 1, dirY: -1 },
        { name: 'bottom-right',x: () => width,y: () => height,dirX: -1, dirY: -1 }
      ];

      // corner emit timers/next intervals
      const cornerState = corners.map(() => ({ next: 0 }));

      // spawn corner particles: subtle inward drift with spread
      function cornerTick(now) {
        // don't run if reduced motion requested
        const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (reduceMotion) return;

        for (let i = 0; i < corners.length; i++) {
          const c = corners[i];
          const state = cornerState[i];
          if (now >= state.next) {
            // set next time
            state.next = now + randRange(CORNER.intervalMin, CORNER.intervalMax);

            // how many to spawn this time
            const count = Math.round(randRange(CORNER.minSpawn, CORNER.maxSpawn));
            for (let k = 0; k < count; k++) {
              // start slightly inset so squares look like they emanate from corner edge
              const inset = randRange(2, 22);
              const cx = clamp(c.x() + (c.dirX === -1 ? -inset : inset), -8, width + 8);
              const cy = clamp(c.y() + (c.dirY === -1 ? -inset : inset), -8, height + 8);

              // direction toward center-ish with random spread
              const centerAngle = Math.atan2(height * 0.45 - cy, width * 0.5 - cx); // a gentle bias toward center-left/top etc
              // convert centerAngle to degrees then add small spread bias outward/inward
              const deg = centerAngle * 180 / Math.PI;
              const spread = randRange(-CORNER.spreadDeg, CORNER.spreadDeg);
              const finalAngle = (deg + spread) * Math.PI / 180;
              const speed = randRange(CORNER.speedMin, CORNER.speedMax);
              const vx = Math.cos(finalAngle) * speed;
              const vy = Math.sin(finalAngle) * speed;

              // choose slightly warmer/redder colors for corner emitters to give them character
              const cornerColorA = [255, 58, 50]; // a slightly redder tone
              const cornerColorB = [255, 130, 60];

              // size & life for corner particles (separate)
              const size = randRange(CORNER.sizeMin, CORNER.sizeMax);
              const life = randRange(CORNER.lifeMin, CORNER.lifeMax);

              spawnParticle(cx, cy, vx, vy, { size, life, colorA: cornerColorA, colorB: cornerColorB });
            }
          }
        }
      }
      // ---------- end corner emitters ----------

      // animation frame
      let last = performance.now();
      function loop(now) {
        const dt = now - last;
        last = now;
        ctx.clearRect(0, 0, width, height);

        // ambient spawns (mask-driven) - unchanged
        maybeAmbient(now);

        // corner emitters
        cornerTick(now);

        // update & draw particles (shared for mouse & corners)
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.age += dt;
          if (p.age >= p.life) {
            particles.splice(i, 1);
            continue;
          }
          // update physics
          p.vx *= FRICTION;
          p.vy *= FRICTION;
          p.x += p.vx * (dt / 16.67); // normalize per-frame (60fps base)
          p.y += p.vy * (dt / 16.67);

          // visual alpha: fade out over lifetime, plus a tiny global dim so corners feel atmospheric
          const alpha = (1 - (p.age / p.life)) * 1.0;

          // draw square with crisp edges (use integer coords)
          ctx.globalAlpha = alpha;
          ctx.fillStyle = `rgb(${p.rgb[0]},${p.rgb[1]},${p.rgb[2]})`;
          const s = Math.round(p.size);
          ctx.fillRect(Math.round(p.x - s / 2), Math.round(p.y - s / 2), s, s);
        }

        ctx.globalAlpha = 1;
        requestAnimationFrame(loop);
      }

      // pointer events (unchanged)
      let lastEvent = null;
      window.addEventListener('mousemove', (e) => {
        const mx = e.clientX;
        const my = e.clientY;
        let movementX = 0, movementY = 0;
        if (lastEvent) {
          movementX = mx - lastEvent.clientX;
          movementY = my - lastEvent.clientY;
        }
        handleMove(mx, my, movementX, movementY);
        lastEvent = e;
      }, { passive: true });

      window.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches[0]) return;
        const t = e.touches[0];
        handleMove(t.clientX, t.clientY, 0, 0);
      }, { passive: true });

      window.addEventListener('touchmove', (e) => {
        if (!e.touches || !e.touches[0]) return;
        const t = e.touches[0];
        let movementX = 0, movementY = 0;
        if (lastEvent && lastEvent.touches && lastEvent.touches[0]) {
          movementX = t.clientX - lastEvent.touches[0].clientX;
          movementY = t.clientY - lastEvent.touches[0].clientY;
        }
        handleMove(t.clientX, t.clientY, movementX, movementY);
        lastEvent = e;
      }, { passive: true });

      window.addEventListener('mouseleave', () => {
        lastEvent = null;
      });

      // small helpers
      function randRange(a, b) { return a + Math.random() * (b - a); }
      function lerp(a, b, t) { return a + (b - a) * t; }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // Build mask points when image loads
      maskImg.addEventListener('load', () => {
        try { buildMaskPoints(); } catch (e) { maskReady = false; }
      });
      if (maskImg.complete) {
        try { buildMaskPoints(); } catch (e) { maskReady = false; }
      }

      // initialize & entrance animations (kept)
      function initEntrance() {
        const container = document.getElementById('pageContainer');
        const photo = document.getElementById('profilePhoto');
        const text = document.getElementById('textContent');

        requestAnimationFrame(() => {
          setTimeout(() => {
            container.classList.add('show');
            setTimeout(() => photo.classList.add('show'), 90);
            setTimeout(() => text.classList.add('show'), 160);
          }, 90);
        });
      }

      // decide whether to run motion effects
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // initialize everything
      resize();
      window.addEventListener('resize', resize, { passive: true });

      if (!reduceMotion) {
        // tasteful bursts on load (kept)
        const cx = Math.round(width / 2);
        const cy = Math.round(height / 3.5);
        spawnBurst(cx, cy, 46, 4.6);

        const photoEl = document.getElementById('profilePhoto');
        let rect = photoEl && photoEl.getBoundingClientRect ? photoEl.getBoundingClientRect() : null;
        if (rect) {
          spawnBurst(rect.left + rect.width / 2, rect.top + rect.height / 2, 18, 2.6);
        } else {
          spawnBurst(width * 0.55, height * 0.45, 18, 2.6);
        }

        requestAnimationFrame(loop);
      } else {
        (function noMotionLoop(){ requestAnimationFrame(noMotionLoop); })();
      }

      // show content (CSS transitions)
      initEntrance();

    })();
  </script>
</body>
</html>
