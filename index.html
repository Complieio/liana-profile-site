<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Liana — profile</title>

  <style>
    :root{
      --accent-gradient: linear-gradient(90deg, #FF3D3D 0%, #FF914D 100%);
      --bg-color: #000;
      --text: #e6e6e6;
      --muted: #bdbdbd;
      --max-width: 820px;
    }

    /* Reset / base */
    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; background:var(--bg-color); color:var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    a { text-decoration: none; }

    /* Canvas background (the orange pixel effect) */
    canvas#bgCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;              /* behind the page content */
      pointer-events: none;    /* won't block clicks */
      display:block;
      background: radial-gradient(1200px 600px at 10% 10%, rgba(255,61,61,0.03), transparent 8%),
                  radial-gradient(900px 400px at 90% 90%, rgba(255,145,77,0.02), transparent 10%);
    }

    /* subtle vignette */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      background: radial-gradient(60% 60% at 50% 40%, rgba(255,255,255,0.02), transparent 30%),
                  radial-gradient(100% 100% at 50% 80%, rgba(0,0,0,0.45), rgba(0,0,0,0.6));
      mix-blend-mode: multiply;
    }

    /* Page layout */
    .page { min-height:100vh; display:flex; align-items:flex-start; justify-content:center; padding:56px 20px; z-index:1; position:relative; }
    .container {
      width:100%;
      max-width: var(--max-width);
      margin: 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 22px;
      transform-origin: center;
      opacity: 0;
      transform: translateY(12px) scale(0.995);
      transition: opacity 520ms cubic-bezier(.2,.9,.2,1), transform 520ms cubic-bezier(.2,.9,.2,1);
      will-change: opacity, transform;
    }

    .container.show {
      opacity: 1;
      transform: none;
    }

    /* Photo: centered medium size with slightly rounded corners */
    .photo {
      width: 200px;
      height: 200px;
      object-fit: cover;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 20px 50px rgba(0,0,0,0.6);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      display:block;
      transform-origin: center;
      transform: scale(0.9) rotate(-1.2deg);
      opacity: 0;
      transition: transform 680ms cubic-bezier(.2,.9,.25,1), opacity 680ms cubic-bezier(.2,.9,.25,1);
    }

    .photo.show {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }

    /* Content column */
    .content {
      width:100%;
      padding: 0 12px;
      color: var(--muted);
      line-height:1.55;
      text-align: left;
      transform-origin: left top;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 680ms cubic-bezier(.2,.9,.25,1) 140ms, transform 680ms cubic-bezier(.2,.9,.25,1) 140ms;
    }

    .content.show {
      opacity: 1;
      transform: none;
    }

    .intro {
      margin: 8px 0 12px 0;
      color: var(--text);
      font-size: 15px;
    }

    .current, .email {
      margin: 6px 0 12px 0;
      color: var(--muted);
      font-size: 15px;
    }

    /* Gradient-accent links with subtle shimmer */
    .accent-link {
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
      font-weight: 600;
      background-size: 200% 100%;
      background-position: 0% 50%;
      transition: background-position 900ms linear;
    }
    .accent-link:hover { background-position: 100% 50%; }
    a.accent-link:visited { opacity: 0.95; }

    /* Lists */
    .content h3 { margin-top:14px; margin-bottom:8px; color:var(--text); font-size:15px; }
    ul { margin:6px 0 12px 20px; padding:0; }
    li { margin-bottom:8px; color:var(--muted); }

    .social-label { color: var(--text); font-weight:600; margin-right:6px; }

    a { color: #ffaf88; }

    /* small screen tweaks */
    @media (max-width:640px) {
      .photo { width:160px; height:160px; border-radius:10px; }
      .container { padding: 0 6px; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      canvas#bgCanvas { display: none; }
      .container, .photo, .content { transition: none; transform: none; opacity: 1 !important; }
      body::after { display:none; }
    }
  </style>
</head>
<body>
  <!-- Canvas for the small-square trail effect -->
  <canvas id="bgCanvas" aria-hidden="true"></canvas>

  <main class="page">
    <div class="container" id="pageContainer">

      <!-- Photo (centered) -->
      <img class="photo" id="profilePhoto" src="assets/profile.jpg" alt="Liana portrait" width="200" height="200" />

      <!-- Content area -->
      <div class="content" id="textContent">
        <p class="intro">
          I'm Liana, a 14 y/o entrepreneur based in Sweden. I like reading, creating stuff online, and finding new things worth getting good at.
        </p>

        <p class="current">
          Founder of Complie.io — tools that help professionals track their clients, projects, and tasks in a more efficient way.
        </p>

        <h3>Experience</h3>
        <ul>
          <li>Freelanced building websites</li>
          <li>Edited videos + clips for creators</li>
          <li>Created faceless YouTube content</li>
          <li>Skilled in video editing &amp; graphic design</li>
          <li>Sales experience through consistent outreach</li>
          <li>Built a platform (Complie)</li>
        </ul>

        <h3>Socials</h3>
        <ul>
          <li>
            <span class="social-label">X:</span>
            <a class="accent-link" href="https://x.com/Lianarooz" target="_blank" rel="noopener">@Lianarooz</a>
          </li>
          <li>
            <span class="social-label">LinkedIn:</span>
            <a class="accent-link" href="https://www.linkedin.com/in/liana-roozbahani-998956353/" target="_blank" rel="noopener">Liana Roozbahani</a>
          </li>
          <li>
            <span class="social-label">Instagram:</span>
            <a class="accent-link" href="https://www.instagram.com/lianaroozbahani/" target="_blank" rel="noopener">@lianaroozbahani</a>
          </li>
          <li>
            <span class="social-label">GitHub:</span>
            <a class="accent-link" href="https://github.com/Complieio" target="_blank" rel="noopener">Complieio</a>
          </li>
          <li>
            <span class="social-label">Email:</span>
            <a class="accent-link" href="mailto:roozbahaniliana@gmail.com">roozbahaniliana@gmail.com</a>
          </li>
        </ul>
      </div>
    </div>
  </main>

  <script>
    (function () {
      const canvas = document.getElementById('bgCanvas');
      const ctx = canvas.getContext('2d', { alpha: true });

      // ---------- Tweak these to change the effect ----------
      const SPAWN_COUNT = 3;        // how many squares to spawn per mousemove event (1-6)
      const PARTICLE_MIN_SIZE = 6;  // px (small squares)
      const PARTICLE_MAX_SIZE = 12; // px
      const LIFESPAN_MIN = 300;     // ms
      const LIFESPAN_MAX = 900;     // ms
      const MAX_PARTICLES = 800;    // cap for performance
      const FRICTION = 0.86;        // how quickly particles slow
      // -----------------------------------------------------

      let DPR = Math.max(window.devicePixelRatio || 1, 1);
      let width = 0, height = 0;
      let particles = [];
      let lastMouse = { x: -9999, y: -9999, t: performance.now() };

      function resize() {
        DPR = Math.max(window.devicePixelRatio || 1, 1);
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.width = Math.round(width * DPR);
        canvas.height = Math.round(height * DPR);
        // scale drawing so coordinates can be in CSS pixels
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }

      // create a single particle
      function spawnParticle(x, y, vx = 0, vy = 0) {
        if (particles.length >= MAX_PARTICLES) return;
        const size = randRange(PARTICLE_MIN_SIZE, PARTICLE_MAX_SIZE);
        const life = randRange(LIFESPAN_MIN, LIFESPAN_MAX);
        // color blend between two oranges for slight variety
        const colorA = [255, 61, 61];   // #FF3D3D
        const colorB = [255, 145, 77];  // #FF914D
        const mix = Math.random();
        const r = Math.round(lerp(colorA[0], colorB[0], mix));
        const g = Math.round(lerp(colorA[1], colorB[1], mix));
        const b = Math.round(lerp(colorA[2], colorB[2], mix));
        particles.push({
          x, y,
          vx: vx + randRange(-0.5, 0.5),
          vy: vy + randRange(-0.5, 0.5),
          size,
          life,
          age: 0,
          rgb: [r, g, b]
        });
      }

      // spawn several based on movement speed and SPAWN_COUNT
      function handleMove(clientX, clientY, movementX, movementY) {
        const speed = Math.sqrt(movementX * movementX + movementY * movementY);
        const count = Math.min(6, Math.max(1, Math.round(SPAWN_COUNT + speed * 0.02)));
        for (let i = 0; i < count; i++) {
          const ox = randRange(-4, 4);
          const oy = randRange(-4, 4);
          const vx = movementX * 0.15 + randRange(-0.6, 0.6);
          const vy = movementY * 0.15 + randRange(-0.6, 0.6);
          spawnParticle(clientX + ox, clientY + oy, vx, vy);
        }
      }

      // spawn a radial burst from a center point (used on load)
      function spawnBurst(cx, cy, count = 40, speed = 3.5) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const spd = randRange(speed * 0.4, speed * 1.1);
          const vx = Math.cos(angle) * spd + randRange(-0.6, 0.6);
          const vy = Math.sin(angle) * spd + randRange(-0.6, 0.6);
          const ox = Math.cos(angle) * randRange(0, 6);
          const oy = Math.sin(angle) * randRange(0, 6);
          spawnParticle(cx + ox, cy + oy, vx, vy);
        }
      }

      // small ambient periodic spawns (very subtle)
      let ambientTimer = 0;
      function maybeAmbient(now) {
        // every ~1.6 - 3s create a tiny drift somewhere near the center or edges
        if (now - ambientTimer > randRange(1600, 3000)) {
          ambientTimer = now;
          // choose a random sector near center-ish
          const cx = randRange(width * 0.25, width * 0.75);
          const cy = randRange(height * 0.2, height * 0.8);
          const n = Math.round(randRange(1, 4));
          for (let i = 0; i < n; i++) {
            spawnParticle(cx + randRange(-20,20), cy + randRange(-20,20), randRange(-0.4,0.4), randRange(-0.4,0.4));
          }
        }
      }

      // animation frame
      let last = performance.now();
      function loop(now) {
        const dt = now - last;
        last = now;
        ctx.clearRect(0, 0, width, height);

        // ambient spawns
        maybeAmbient(now);

        // update & draw particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.age += dt;
          if (p.age >= p.life) {
            particles.splice(i, 1);
            continue;
          }
          p.vx *= FRICTION;
          p.vy *= FRICTION;
          p.x += p.vx * (dt / 16.67);
          p.y += p.vy * (dt / 16.67);

          const alpha = 1 - (p.age / p.life);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = `rgb(${p.rgb[0]},${p.rgb[1]},${p.rgb[2]})`;
          const s = Math.round(p.size);
          ctx.fillRect(Math.round(p.x - s / 2), Math.round(p.y - s / 2), s, s);
        }

        ctx.globalAlpha = 1;
        requestAnimationFrame(loop);
      }

      // pointer events
      let lastEvent = null;
      window.addEventListener('mousemove', (e) => {
        const mx = e.clientX;
        const my = e.clientY;
        let movementX = 0, movementY = 0;
        if (lastEvent) {
          movementX = mx - lastEvent.clientX;
          movementY = my - lastEvent.clientY;
        }
        handleMove(mx, my, movementX, movementY);
        lastEvent = e;
      }, { passive: true });

      window.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches[0]) return;
        const t = e.touches[0];
        handleMove(t.clientX, t.clientY, 0, 0);
      }, { passive: true });

      window.addEventListener('touchmove', (e) => {
        if (!e.touches || !e.touches[0]) return;
        const t = e.touches[0];
        let movementX = 0, movementY = 0;
        if (lastEvent && lastEvent.touches && lastEvent.touches[0]) {
          movementX = t.clientX - lastEvent.touches[0].clientX;
          movementY = t.clientY - lastEvent.touches[0].clientY;
        }
        handleMove(t.clientX, t.clientY, movementX, movementY);
        lastEvent = e;
      }, { passive: true });

      window.addEventListener('mouseleave', () => {
        lastEvent = null;
      });

      // small helpers
      function randRange(a, b) { return a + Math.random() * (b - a); }
      function lerp(a, b, t) { return a + (b - a) * t; }

      // initialize & entrance animations
      function initEntrance() {
        const container = document.getElementById('pageContainer');
        const photo = document.getElementById('profilePhoto');
        const text = document.getElementById('textContent');

        // Wait a tick so CSS transitions run — apply show classes in staged manner
        requestAnimationFrame(() => {
          // small delay so burst can happen slightly before content appears
          setTimeout(() => {
            container.classList.add('show');
            setTimeout(() => photo.classList.add('show'), 90);
            setTimeout(() => text.classList.add('show'), 160);
          }, 90);
        });
      }

      // decide whether to run motion effects
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // initialize everything
      resize();
      window.addEventListener('resize', resize, { passive: true });

      if (!reduceMotion) {
        // burst from center on load & a gentle secondary burst near the photo
        const cx = Math.round(width / 2);
        const cy = Math.round(height / 3.5);
        // small first-pop for "arriving" feeling
        spawnBurst(cx, cy, 46, 4.6);
        // second, subtle burst where the profile photo is (if available)
        // attempt to compute photo center; fallback to center-bottom area
        const photo = document.getElementById('profilePhoto');
        let rect = photo && photo.getBoundingClientRect ? photo.getBoundingClientRect() : null;
        if (rect) {
          spawnBurst(rect.left + rect.width / 2, rect.top + rect.height / 2, 18, 2.6);
        } else {
          spawnBurst(width * 0.55, height * 0.45, 18, 2.6);
        }

        // start animation loop
        requestAnimationFrame(loop);
      } else {
        // if reduced motion, don't run the particle loop and just show content
        // but still start an empty loop to keep code stable (no drawing)
        (function noMotionLoop(){ requestAnimationFrame(noMotionLoop); })();
      }

      // show content (CSS transitions)
      initEntrance();

    })();
  </script>
</body>
</html>
